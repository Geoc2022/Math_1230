\lecture{4}{2023-02-09}{}

\subsection{Prüfer Codes}
\begin{definition}[prüfer code]
    \label{def:prüfer code}
    A code derived from a tree by iteratively removing the smallest degree vertex and adjoining its neighbor until there are only two vertices left.
\end{definition}

\begin{example}[prüfer code to tree]
    \label{ex:prufer code to tree}
    Let's take the example \((1,4,1,1)\)

    We know that vertices of deg \(1\) do not appear, so we start with an edge from \(2\) to \(1\)  then we remove \(1\) from the list. Next we start with \(4\) and add the next deg \(1\) vertex. Now we have a connection from \(4\) to \(1\) since it's left in the Prüfer code. Then we finally create a tree with vertices \(1,5,6\) and adjoin it.
\end{example} 

\begin{theorem}
    For each sequence \((a_1 \ldots a_{n-2})\) there exists a unique tree \(T\) with \(P(T) = (a_1 \ldots a_{n-2})\)
\end{theorem}
\begin{proof}
    By induction:
    
    \emph{Base Case:} \(n = 2\)

    Sequences have length \(n = 2 = 0\) and there is only one tree with \(2\) vertices

    \emph{Inductive Step:}

    For any tree with code \((\vec{a_1} \ldots a_{n-2})\) Let \(x\) be the smallest index not in the sequence then we can construct an edge between it and \(a_1\) and remove \(a_1\) from the code. Therefore, we have a code with one less element. And, by induction, \(\exists !\) a tree \(T^\prime\) with vertices \(\{1\ldots n\}\setminus{x}\)  and code \((a_2 \ldots a_{n-2})\).

    The uniqueness come from the fact that \(T^\prime\) is unique and there is only one way to add an edge
\end{proof}
\begin{theorem}[Cayley]
    \label{thm:cayley}
    There is a bijection between trees and these sequences. Therefore, we can count trees easily by counting sequences.

    Therefore, we find there are \(n^{n-2}\) trees given \(n\) vertices
\end{theorem} 